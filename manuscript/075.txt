## Состояние

Состояние (`state`) — важное понятие в объектно-ориентированном языке. Руби это объектно-ориентированный язык. Другие примеры объектно-ориентированных языков: Java, C#, JavaScript. Существуют также другие, частично объектно-ориентированные языки ([Golang](https://golang.org/doc/faq#Is_Go_an_object-oriented_language)), т.н. функциональные языки программирования (Erlang/Elixir, Haskell) и пр.

Основное отличие объектно-ориентированного языка от не-объектно-ориентированного в том, что в объектно-ориентированном языке есть такое понятие как состояние объекта. Что же такое состояние?

Обратимся к нашему примеру с автомобилем BMW модели E34. Итак, где-то на заводе в Германии существует чертеж этого автомобиля, именно этой модели. По этому чертежу фабрикой было выпущено множество экземпляров автомобиля. Но автомобиль собран из отдельных деталей:

* Двигатель
* Лобовое стекло
* Кузов
* Двери
* Колеса, и т.д.

Все эти объекты бездушные, не живые, и не представляют никакой ценности. Кто в своем уме купит колесо от автомобиля просто ради того, чтобы принести его домой? В этом нет никакого смысла. Но будучи собранным, автомобиль превращается в живой организм, в объект, у него появляется состояние.

Несмотря на то, что все выпущенные машины на заводе за много лет были одинаковыми, у всех у них на данный момент сейчас совершенно разное состояние. Состояние отличает один конкретный автомобиль от множества точно таких же. В чем же выражается это состояние?

Во-первых, пробег. Автомобиль довольно сложный механизм, и вряд ли у двух автомобилей существует одинаковый пробег с точностью до метра. Во-вторых, это может быть любой другой параметр: например, бензин в баке. Количество бензина в баке отражает состояние конкретного объекта «автомобиль BMW марки E34». Мы знаем, что количество бензина меняется: мы можем приехать на заправку и изменить состояние этого объекта, долив бензина. В-третьих, включен автомобиль или выключен — это тоже состояние.

Другими словами, в объектно-ориентированном языке объект — это живой механизм, у которого есть состояние. Это состояние каким-то образом можно менять. Это можно делать извне, а можно делать и изнутри. Если мы подходим к автомобилю и открываем дверь, то мы меняем объект извне. А если заводим его, находясь в автомобиле — то меняем состояние изнутри. Автомобиль сам может менять свое состояние. Например, когда двигатель нагревается до определенной температуры, включается принудительное охлаждение.

Попробуем написать программу, которая продемонстрирует вышесказанное:

{line-numbers: false}
```ruby
class Car
  def initialize
    @state = :closed
  end

  def open
    @state = :open
  end

  def how_are_you
    puts "My state is #{@state}"
  end
end

car1 = Car.new
car1.how_are_you

car2 = Car.new
car2.open
car2.how_are_you
```

Результат работы программы:

{line-numbers: false}
```ruby
My state is closed
My state is open
```

Мы создали класс `Car` — начертили «чертеж» автомобиля с помощью языка руби. Далее мы создали объект (экземпляр) с помощью конструкции `Car.new` и присвоили переменной `car1` ссылку на этот объект. Важно отметить, что переменная car1 не «содержит» сам объект, это просто ссылка на область памяти где на самом деле этот объект хранится. Можно вспомнить аналогию с подъездом. Звонок — это ссылка на квартиру. Также и тут: переменная — это ссылка на объект. Мы можем иметь любое количество переменных, указывающих на один и тот же объект. Захотим и присвоим переменной `car777` значение `car1`:

{line-numbers: false}
```ruby
car777 = car1
```

Далее в нашей программе мы спрашиваем у объекта — «how are you», на что объект сообщает о своем состоянии. Первый объект сообщил, что «My state is closed» (мое состояние — закрыто), но почему это произошло? Дело в том, что мы объявили метод `initialize`:

{line-numbers: false}
```ruby
  def initialize
    @state = :closed
  end
```

Этот метод всегда вызывается при создании нового объекта. Другими словами, когда вы пишите `Car.new`, будет вызван метод `initialize`. Непонятно почему в языке руби выбрали такое длинное слово в котором легко сделать ошибку. Согласитесь, что гораздо проще выглядел бы такой код:

{line-numbers: false}
```ruby
class Car
  def new
    # ...
  end
end

Car.new
``` 

Но к сожалению приходится использовать длинное слово `initialize`. Кстати, этот метод называется «конструктор», и в языке JavaScript версии ES6 и выше он именуется именно так:

{line-numbers: false}
```js
class Car {
  constructor() {
    console.log('hello from constructor!');
  }
}

let car1 = new Car();
```

Если запустить программу выше (например, `$ node` и вставить текст), то мы увидим сообщение «hello from constructor!». Т.е. метод был вызван при создании объекта. Тот же самый код в руби выглядит следующим образом:

{line-numbers: false}
```ruby
class Car
  def initialize
    puts 'hello from constructor!'
  end
end

car1 = Car.new
```

Это один из не самых очевидных моментов в языке Ruby — пишем `new`, а вызывается `initialize`.

Для чего существует конструктор? Для того, чтобы определить начальное состояние объекта. Скажем, при выпуске автомобиля мы хотим чтобы: двери автомобиля были закрыты, окна были закрыты, капот и багажник были закрыты, все выключатели были переведены в положение «Выключено» и т.д.

Вы, наверное, обратили внимание, что мы использовали знак `@` (читается как `at`) перед переменной `state` в конструкторе. Этот знак говорит о том, что это будет `instance variable` — переменная экземпляра. Мы как-то говорили об этом в предыдущих главах. Но вообще, существует три типа переменных:

Локальные переменные. Это переменные, объявленные в каком-то методе. Эти переменные недоступны из других методов. Если вы напишите вот такой код, то программа выдаст ошибку, потому что переменная `aaa` не определена в методе `m2`:

{line-numbers: false}
```ruby
class Foo
  def m1
    aaa = 123
    puts aaa
  end

  def m2
    puts aaa
  end
end

foo = Foo.new
foo.m1 # сработает, будет выведено 123
foo.m2 # будет ошибка, переменная не определена
```

*Instance variables* — переменные экземпляра класса. К ним можно обращаться только через `@`:

{line-numbers: false}
```ruby
class Foo
  def initialize
    @aaa = 123
  end

  def m1
    puts @aaa
  end

  def m2
    puts @aaa
  end
end

foo = Foo.new
foo.m1
foo.m2
```

Эти переменные определяют *состояние объекта*. Желательно объявлять `instance variables` в конструкторе, чтобы показать намерение: вот эта переменная будет отвечать за состояние, мы будем ее использовать. Однако, не будет синтаксической ошибки если вы объявите `instance variable` в каком-то методе. Просто этот метод должен быть вызван прежде, чем какой-либо другой метод обратится к этой переменной (а конструктор вызывается всегда при создании объекта). Объявляем переменную в методе `m1` и используем ее в методе `m2`:

{line-numbers: false}
```ruby
class Foo
  def m1
    @aaa = 123
    puts @aaa
  end

  def m2
    puts @aaa
  end
end

foo = Foo.new
foo.m1
foo.m2
```

Результат работы программы:

{line-numbers: false}
123
123
```

Если в программе выше поменять две последние строки местами, то фактического сообщения об ошибке не будет, программа сработает, но на экран будет выведена только одна строка:

{line-numbers: false}
123
```

Руби попытается вызвать метод `m2`, т.к. переменная экземпляра класса не объявлена, то ее значение будет равно по-умолчанию `nil`, а `puts nil` не выводит на экран строку. В этом заключается первая любопытная особенность `instance variable` — если эта переменная не объявлена, то ее значение по-умолчанию равно `nil`. Если локальная переменная не объявлена, то будет ошибка исполнения программы.

*Class variables* — переменные класса, переменные шаблона, иногда называются статическими переменными. Совершенно бесполезный тип переменных с префиксом `@@`. Смысл в том, что какое-то значение можно будет менять между всеми экземплярами класса. На практике это встречается довольно редко. 

Можно выделить еще два типа переменных:

* Глобальные переменные (с префиксом `$`) — обратиться к этим переменным можно из любого места программы. Однако, из-за этой особенности возникает большой соблазн их использовать, что только приводит к запутанности программы. 
* Специальные переменные. Например, переменная `ARGV` содержит аргументы, переданные в программу. А переменная `ENV` содержит параметры окружения (`environment`) — т.е. параметры, которые заданы в вашей оболочке (`shell`).

Другими словами, для создания программ в общем случае необходимо усвоить разницу между локальными переменными и `instance variables` (переменными экземпляра класса, которые определяют состояние объекта).

А теперь вопрос. Что делает следующая программа?

{line-numbers: false}
```ruby
puts aaa
```

Кто-то скажет «выводит переменную `aaa` на экран». И будет прав, ведь можно записать программу полностью следующим образом:

{line-numbers: false}
```ruby
aaa = 123
puts aaa
``` 

Но что если мы запишем программу иначе:

{line-numbers: false}
```ruby
def aaa
  rand(1..9)
end

puts aaa
```

Программа будет выводить случайное значение (в пределах от 1 до 9). Другими словами, мы не можем точно сказать что именно означает `puts aaa`, мы только знаем, что `aaa` — это или переменная, или метод, или что-то еще. Про «что-то еще» мы поговорим подробнее в следующих главах, когда будем говорить о специальном методе `method_missing` («метод отсутствует»). 

А пока наш класс выглядит следующим образом:

{width: 30%}
![Диаграмма классов автомобилей](images/075-diagram-01.png)

Из картинки видно, что полезных методов только два (два красных круга внизу и один конструктор). Т.е. снаружи мы можем только открыть дверь и попросить рассказать о своем состоянии (или создать объект с помощью конструктора). Состояние хранится в `instance variable`, и по-умолчанию мы никак не можем обратиться непосредственно к этой переменной снаружи. Состояние может быть каким угодно, мы можем завести 10 переменных, и внутри объекта реализовать любую сложную логику, но интерфейс взаимодействия (API, или сигнатуры методов) остается прежним.

Если продолжить аналогию с реальным автомобилем, то внутри класса мы, может быть, захотим играть музыку. Но до тех пор, пока мы не реализовали это в API нашего объекта, о внутреннем состоянии никто не узнает — играет музыка внутри автомобиля или нет. Это называется инкапсуляция.

Но, допустим, вы ехали по улице и решили подвезти прекрасную девушку. Вы остановились, но девушка такая скромная, что не будет сама открывать дверь. Она бы и рада зайти к вам в машину, но хочет видеть, что дверь открыта. Она хочет прочитать состояние нашего объекта и не хочет говорить «how are you» первому встречному. Другими словами, мы хотим всем разрешить читать состояние объекта. Что делать в этом случае?

Самый простой способ — добавить метод с любым названием, который будет возвращать состояние. Мы могли бы добавить метод `aaa`, но давайте назовем его `state`. Код класса полностью:

{line-numbers: false}
```ruby
class Car
  def initialize
    @state = :closed
  end

  # новый метод
  def state
    @state
  end

  def open
    @state = :open
  end

  def how_are_you
    puts "My state is #{@state}"
  end
end
```

Получился следующий класс:

{width: 30%}
![Диаграмма классов автомобилей](images/075-diagram-02.png)

Т.е. само состояние `@state` недоступно, но есть вариант его прочитать с помощью метода `state`. Название состояния и методы похожи и состоят из одного слова, но это для руби это две разные вещи. Мы могли бы назвать метод `aaa`, в этом бы не было ошибки. Отлично, теперь девушка видит, что машина открыта, она может прочитать состояние с помощью метода `state`.

Но вот незадача — снаружи увидеть состояние можно (метод `state`), снаружи можно открыть дверь (`open`), но изменить состояние можно только изнутри. Что в общем-то и нормально — может быть не потребуется интерфейса для закрытия двери снаружи. Но что если потребуется? Задача программиста — подумать о бизнес-логике, о том, как будет использоваться тот или иной компонент.

Если мы точно знаем, что понравимся девушке, то интерфейс закрытия двери снаружи можно не реализовывать. А что если мы захотим закрывать дверь снаружи? Согласитесь, для автомобиля это полезная функциональность. Мы бы могли написать метод `close`:

{line-numbers: false}
```ruby
def close
  @state = :closed
end
```

И проблема была бы решена. Вот один из конечных вариантов класса:

{width: 30%}
![Диаграмма классов автомобилей](images/075-diagram-03.png)

Но что если мы, например, захотим завести автомобиль? Во-первых, наше состояние могло бы быть совокупностью описаний: `open`, `closed`, `engine_on`, `engine_off` (можно было бы представить его в виде массива). А во-вторых, пришлось бы добавлять еще два метода: `on`, `off`. В этом случае к четырем публичным методам прибавилось бы еще два. Получается довольно сложный класс.

Иногда полезно просто оставить возможность управления состоянием извне: делай что хочешь, открывай двери, заводи двигатель, включай музыку. Как вы понимаете, это не всегда приводит к хорошим последствиям, но вполне практикуется.

Для того, чтобы разрешить полное управление переменной экземпляра класса (в нашем случае `@state`), можно написать следующий код:

{line-numbers: false}
```ruby
attr_reader :state
attr_writer :state
``` 

Этот код просто создает в классе два метода, для чтения переменной и для ее записи:

{line-numbers: false}
```ruby
def state
  @state
end

def state=(value)
  @state = value
end
```

Первый метод нам уже знаком — мы его создали для возврата состояния. Второй метод по сути уже содержит в себе знак равно и используется для присваивания. Но `attr_reader` и `attr_writer` можно заменить на всего-лишь одну строку:

{line-numbers: false}
```ruby
attr_accessor :state
```

(Не путайте `attr_accessor` и `attr_accessible`, которое используется во фреймворке Rails, это разные понятия, но слова выглядят одинаково).

Весь наш класс можно свести к такому простому коду:

{line-numbers: false}
```ruby
class Car
  attr_accessor :state

  def initialize
    @state = :closed
  end

  def how_are_you
    puts "My state is #{@state}"
  end
end
```

Пример использования:

{line-numbers: false}
```ruby
car1 = Car.new
car1.state = :open

car2 = Car.new
car2.state = :broken

car1.how_are_you
car2.how_are_you
```

Результат работы программы:

{line-numbers: false}
```
My state is open
My state is broken
```

Визуальное представление класса:

{width: 30%}
![Диаграмма классов автомобилей](images/075-diagram-04.png)

X> ## Задание 1: 
X> Напишите класс Monkey («обезьянка»). В классе должно быть 1) реализовано два метода: `run`, `stop`; 2) каждый из методов должен менять состояние объекта; 3) `you must expose the state of an object` так, чтобы можно было узнать о состоянии класса снаружи, но нельзя было его модифицировать (к сожалению, точно перевести на русский язык выражение «expose the state» не получилось. Посмотрите перевод слова «expose» в словаре). Создайте экземпляр класса `Monkey`, вызовите методы объекта и проверьте работоспособность программы.
>
X> ## Задание 2: 
X> Сделайте так, чтобы при инициализации класса `Monkey` экземпляру присваивалось случайное состояние. Создайте массив из десяти обезьянок. Выведите состояние всех элементов массива на экран.

Читайте также: «[Скрывайте секреты. Инкапсулируйте детали реализации](https://vk.com/@physics_math-skryvaite-sekrety-inkapsuliruite-detali-realizacii)».
